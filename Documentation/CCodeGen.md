# C++ Code generation

## API

```python
def ccode(self,directory,config=Configuration())
```

It is a method of the `Schedule` object returned by `computeSchedule`.

It generate C++ code implementing the static schedule.

* `directory` : The directory where to generate the C++ files
* `config` : An optional configuration object

## Options for C Code Generation

### cOptionalArgs (default = "")

Optional arguments to pass to the C API of the scheduler function

It can either use a `string` or a list of `string` where an element is an argument of the function (and should be valid `C`).

For instance, with:

```Python
conf.cOptionalArgs=["int someVariable"]
```

The API of the generated scheduler function would be:

```C++
uint32_t scheduler(int *error,int someVariable)
```

### switchCase (default = True)

When the schedule is encoded as an array, it can either be an array of function pointers (`switchCase` false) or an array of indexes for a state machine (`switchCase` true)

### eventRecorder (default = False)

Enable the generation of `CMSIS EventRecorder` intrumentation in the code. You need to use the file `cg.scvd` that is providing definition of the following events for display in the Event Recorder:

* Schedule iteration
* Node execution
* Error

### customCName (default = "custom.h")

Name of custom header in generated C code. If you use several scheduler, you may want to use different headers for each one.

### postCustomCName (default = "")

Name of custom header in generated C code coming after all of the other includes.  By default none is used.

### genericNodeCName (default = "GenericNodes.h")

Name of GenericNodes header in generated C code. If you use several scheduler, you may want to use different headers for each one.

This file can be used from the CMSIS-Stream repository. It can also be generated by the Python using the function `generateGenericNodes(destination_folder)`

### appNodesCName (default = "AppNodes.h")

Name of AppNodes header in generated C code. If you use several scheduler, you may want to use different headers for each one.

### schedulerCFileName (default = "scheduler")

Name of scheduler `cpp` and header in generated C code. If you use several scheduler, you may want to use different headers for each one.

If the option is set to `xxx`, the names generated will be `xxx.cpp` and `xxx.h`

### CAPI (default = True)

By default, the scheduler function is callable from C. When false, it is a standard C++ API.

### CMSISDSP (default = False)

If you use any of the datatypes or functions of the CMSIS-DSP, you need to include the `arm_math.h` in the scheduler file. This option can thus be set to `True`. You can also use the `custom.h` header file to include any additional header

When this property is false, `cstdint` is included instead of `arm_math.h` to provide definitions for standard types like `int32_t`, `uint32_t` etc ... Otherwise those definitions are provided by `arm_math.h`

### asynchronous (default = False)

When true, the scheduling is for a dynamic / asynchronous flow. A node may not always produce or consume the same amount of data. As consequence, a scheduling can fail. Each node needs to implement a `prepareForRunning` function to identify and recover from FIFO underflows and overflows.

A synchronous schedule is used as start and should describe the average case.

This implies `switchCase`. This disables `memoryOptimizations`.

Synchronous FIFOs that are just buffers will be considered as FIFOs in asynchronous mode.

More info are available in the documentation for [this mode](Async.md).

### FIFOIncrease (default 0)

In case of dynamic / asynchronous scheduling, the FIFOs may need to be bigger than what is computed assuming a static / synchronous scheduling. This option is used to increase the FIFO size. It represents a percent increase.

For instance, a value of `10` means the FIFO will have their size updated from `oldSize` to `1.1 * oldSize` which is ` (1 + 10%)* oldSize`

If the value is a `float` instead of an `int` it will be used as is. For instance, `1.1` would increase the size by `1.1` and be equivalent to the setting `10` (for 10 percent).

### asyncDefaultSkip (default True)

Behavior of a pure function (like CMSIS-DSP) in asynchronous mode. When `True`, the execution is skipped if the function can't be executed. If `False`, an error is raised.

If another error recovery is needed, the function must be packaged into a C++ class to implement a `prepareForRun` function.

### heapAllocation (default False)

By default, C++ objects are assumed to be very light (they are just wrappers around algorithms and the state should be in the algorithms and not in the C++ object). As consequence they are allocated on the stack.

But  with big graphs and lot of objects, or if the user would like to implement the algorithm directly in the C++ object, stack allocation is a problem.

By enabling the `heapAllocation` feature, the FIFOs object and nodes objects are allocated on the heap. Two new functions are generated by CMSIS-Stream : `int init_scheduler()` and `void free_scheduler()`. Note that the name `scheduler` can be changed with the option `schedName`

The buffers for the FIFOs are still declared as global to allow control on where they are mapped.