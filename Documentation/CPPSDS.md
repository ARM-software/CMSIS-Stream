# SDS Nodes

- [SDS Nodes](#sds-nodes)
  - [Introduction](#introduction)
  - [SDS Sensor](#sds-sensor)
    - [sds\_sensor\_cg\_connection\_t](#sds_sensor_cg_connection_t)
    - [Drift compensation](#drift-compensation)
  - [SDS Recorder](#sds-recorder)
    - [sds\_recorder\_cg\_connection\_t](#sds_recorder_cg_connection_t)
  - [Use from outside of the scheduler](#use-from-outside-of-the-scheduler)


## Introduction

The [SDS Framework](https://github.com/ARM-software/SDS-Framework/tree/main) is an Arm framework that allows to record streams of samples and replay them in Virtual Hardware.

The SDS nodes provides a way to use SDS from CMSIS-Stream.

SDS is made of several parts (refer to the project for more details):
* A .yml file describing the sensor (datatype and samplign frequency)
* Binary .sds files containing recorded samples
* Recorders to record samples through different physical interfaces (UART, USB, Wifi ...)
* Sensor API to access to the sensors
* SDS streams (FIFOs) used to read data from the sensors or send data to the recorder

The SDS nodes are providing:
* A SDS sensor class to interface with a sensor
* A SDS recorder class to record samples

There is also a [Python API](PythonSDS.md) to use those nodes in the graph description.

The nodes are located in `Include/cg/nodes/cpp/sds`

## SDS Sensor

The node is a source. It can only work with `uint8_t` datatype and the output of the node is untyped.

The template has been specialized to `uint8_t`:

```C++
template<int outputSize>
class SDSSensor<uint8_t,outputSize>:public NodeBase
```

The constructor of the class is:
```C++
SDSSensor(FIFOBase<uint8_t> &dst,
          sds_sensor_cg_connection_t *sdsConnection,
          driftDelegate_t drift_delegate=nullptr,
          void *delegate_data=nullptr):
```

The first argument if the output FIFO generated by CMSIS-Stream.
The second argument is a struct containing all the information to interact with the sensor handler and sensor SDS streams.
The 3rd and last optional arguments provides a way to implement a drift compensation.

### sds_sensor_cg_connection_t

This datatype is defined in `sds/sds_cg_types.h`

```C
typedef struct {
    uint32_t event;        /* CMSIS RTOS event ID for this sensor */
    uint32_t cancel_event; /* CMSIS RTOS event ID for all sensors */
    uint32_t timeout;      /* Timeout to wait for an event */
    sdsId_t sdsId;         /* SDS stream ID */
} sds_sensor_cg_connection_t;
```

Interaction with the sensor handler is done through CMSIS RTOS event.
There is one event per sensor. The first field of the structure is the event ID for this sensor.

The second field is a cancel event used for all sensors. It is generally used by the sensors are stopped for some reason.

The 3rd field is a timeout : in a realtime system we can't wait for sensor data for an indefinite time. In case of timeout, the sensor node will report a `CG_BUFFER_UNDERFLOW` error and the CMSIS-Stream scheduler will stop.

The last field if the SDS ID of the SDS stream used to receive samples from the sensor.

In synchronous mode the SDS sensor node will block until `outputSize` bytes have been generated on the output. When no drift compensation algorithm is used, it means `outputSize` bytes have been reads from the sensor stream.
With drift compensation, the amount of bytes read from the sensor may be different from `outputSize`.

In asynchronous mode, the sensor node will generate at most `outputSize` bytes. If less bytes are available in the SDS sensor stream, the node will read only what's available in the SDS stream.
If the SDS stream is empty, the node will skip its execution.
If the output FIFO is full, the node will skip its execution.

In case of drift compensation, the node may need more sensor data then expected to generate the output : in that case the node may block until this data is available. One reason for using asynchronous mode is to avoid blocking of some nodes.

As consequence, in asynchronous mode, it is advised to do the drift compensation outside of the sensor node by using another node in the graph.

Drift compensation must be done in the source only for the synchronous case.

### Drift compensation

In some case, the sensor may use a different clock and its clock may drift from the clock used by the MCU.
This drift may have to be corrected for some applications.

Drift compensation means that you may generate a bit more or a bit less data than expected from time to time.

But in synchronous mode, a node must always generate the same amount of data each time it is executed.

So drift compensation cannot be implemented as a node in synchronous mode. That's why the sensor node can accept a drift compensation algorithm as argument.

Drift compensation can also be implemented in the sensor handler.

The datatype is:

```C
typedef uint32_t (*driftDelegate_t) (sdsId_t id, 
                                     void *buf, 
                                     uint32_t buf_size,
                                     void *delegate_data);
```

It is very similar to the API of `sdsRead` :
```C
uint32_t sdsRead (sdsId_t id, void *buf, uint32_t buf_size);
```

The only difference is the argument `delegate_data`.

The drift delegate function attempts to generate `buf_size` bytes. The amount of data generated is returned by the function. It can be less than what was requested and in that case the function will be called again.

## SDS Recorder

The SDS recorder can work with typed data. But in that case you'll need to write a custom `.yml` file to describe the data format if you want to be able to process the recorded data with the SDS utilities.

If you work with `uint8_t` and record the output of the SDS sensor node, then the sensor `.yml` file can be used to process the recorded data.

The constructor of recorder nodes is:

```C++
SDSRecorder(FIFOBase<IN> &src,
            sds_recorder_cg_connection_t *sdsConnection):
```

The first argument if the input FIFO generated by CMSIS-Stream.

The second argument is a struct containing all the information to interact with the recorder.

### sds_recorder_cg_connection_t

This datatype is defined in `sds/sds_cg_types.h`

```C
typedef struct {
    const char *sensorName;    /* Name of sensor */
    uint8_t *recorderBuffer;   /* Recorder buffer descriptions */
    uint32_t recorderBufferSize;
    uint32_t recorderThreshold;
} sds_recorder_cg_connection_t;
```

The first field is the name of the sensor. It is used to create the `.sds` file when recoding the samples.
The other fields describe the recorder buffer. Refer to the SDS documentation.

## Use from outside of the scheduler

To use the SDS nodes, you need to initialize some `sds_sensor_cg_connection_t` and `sds_recorder_cg_connection_t` structures and pass them to the scheduler and the nodes.

One possibility is to define a datastructure containing this information and pass this datastructure to the scheduler:

```C
typedef struct {
sds_sensor_cg_connection_t *sensorConn_accelerometer;
sds_recorder_cg_connection_t *recConn_accelerometer;
} demoContext_t;
```

A variable should be defined with this type:

```C
demoContext_t demoContext;
```

Then the scheduler could be called with:

```C
nbIterations = demo_scheduler(&error,&demoContext);
```