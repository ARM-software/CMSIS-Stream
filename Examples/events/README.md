# README

This example demonstrates the event system of CMSIS Stream with several configuration.

The configurations can be changed in `config_events.h`

# No events 
`CG_EVENTS` is disabled

# With events
`CG_EVENTS` enabled

`source` node is sending an event to `sink` node each time the
`source` run function is executed.

Event processing is interleaved between node execution as defined
in `custom.h`.

The macro can be changed and the event processing could occur less often : at each schedule iteration.

# With events and multi-threading

`CG_EVENTS_MULTI_THREAD` enabled

Events are processed on a background thread.
The example is providing some default Posix implementations for the mutex and thread.

Those implementation can be easily replaced. An RTOS could provide a totally different implementation.

# With host communication
`CG_HOST` is defined

This is an example to show that events can be received and sent to an host.
The example implementation is using sockets.

When this mode is enabled, the node are no more printing their name and the `source` node is no more generating events.

Events are generated from the python script `send_events.py` and the events
are sent to the `sink` node.

Identification of the nodes by the python script is done through the `scheduler_ident.json` that is generated after schedule computation. This `.json` is mapping the node name to a node id that is generated by the scheduling.


You must run the `simple` app first.
Then use `python send_events.py` to connect to the `simple` app.

You may have to change the host and port in the Python script.

The python script also demonstrates how you can use the generated Json file for the selectors ID and node IDs to create virtual objects and methods.

For instance, to send a `value` message to the node `sink` the Python contains:

```python
StreamNetwork.sink.value(s,nb)
```

where `s` is a socket and `nb` the value to send.

A `do` message can be sent with:

```python
StreamNetwork.sink.do(s)
```