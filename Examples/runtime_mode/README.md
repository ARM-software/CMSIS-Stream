# README

This example is **very experimental**.

It is a test of a runtime mode (graph can be changed at runtime without recompiling).

The runtime mode **can** use the schedule pre-computed by the Python script.

The runtime mode **supports** cyclo-static scheduling

Current test is running one iteration of the scheduling.

But the content of the scheduling is defined in `sched_flat.dat` loaded at runtime.

## Limitations:

Those limitations are not temporary.

* No way to have different FIFO implementations for different branches
* No direct support of pure C function. They have to be packaged into a C++ wrapper (original  build mode can call directly a pure function with no state)

## Differences

Static mode node identification is using a `#define` generated by the Python.

The runtime mode is using a `std::string` : the name of the node defined in the Python.

(Only when identification mode is on and a specific node must be identified. Otherwise names are not used)

# How to use

## C++ part

The `AppNodes.h` file must include the runtime nodes instead of the standard generic nodes. The flat buffer generated API must also be included.

```cpp
#include "GenericRuntimeNodes.h"
#include "stream_generated.h"
```

The class must contain the static constant : `uuid` for identification.

And the methods `runNode`, `prepareForRunningNode` and `mkNode`. It is thee un-types API to use and create the node.

Here is an example with a source node.

### The UUID

```cpp
constexpr static std::array<uint8_t,16> uuid    = {0xc0,0x08,0x9f,0x59,0x2f,0x33,0x4e,0xc4,0x90,0x23,0x30,0xf6,0x9f,0x0f,0x48,0x33};

```

### Running the node

It is just a cast before calling the object method

```cpp
static int runNode(NodeBase* obj)
{
    Source *n = reinterpret_cast<Source *>(obj);
    return(n->run());
}
```

### Preparing the node (asynchronous mode)

It is just a cast before calling the object method

```cpp
static int prepareForRunningNode(NodeBase* obj)
{
        Source *n = reinterpret_cast<Source *>(obj);
        return(n->prepareForRunning());
}
```

### Creating a new node

```cpp
static NodeBase* mkNode(const runtime_context &ctx, 
                        const arm_cmsis_stream::Node *ndesc)
{
    auto outputs = ndesc->outputs();
    RuntimeEdge &i = *ctx.fifos[outputs->Get(0)->id()];
        
    Source *node=new Source(*ndesc,i);
    return(static_cast<NodeBase*>(node));
}
```

The `runtime_context_t` `ctx` is containing the FIFO that have been created.

The `ndesc` is the flat buffer description of the node that is containing the FIFO ids for inputs and outputs.

We get the flat buffer description for the output of this node:

```cpp
auto outputs = ndesc->outputs();
```

We extract the corresponding FIFO reference from the runtime context using the flat buffer ID. Here the FIFO is the output port 0 of the node:

```cpp
RuntimeEdge &i = *ctx.fifos[outputs->Get(0)->id()];
```

Then, we call the node constructor:

```cpp
Source *node=new Source(*ndesc,i);
return(static_cast<NodeBase*>(node));
```

### Registering the nodes

Once the nodes have been defined, they need to be registered so that the graph interpreter knows where to find the code:

```cpp
#include "runtime_sched.h"
using namespace arm_cmsis_stream;

static registry_t register_nodes()
{
    registry_t res;

    Component<Source>::reg(res);
    Component<Sink>::reg(res);
    Component<ProcessingNode>::reg(res);
    Component<AdderNode>::reg(res);
    Component<RuntimeDuplicate>::reg(res);
   
    return(res);
};
```

The `RuntimeDuplicate` must **always** be registered.

### Reading the graph

In current example we are reading the graph from a file. The API just needs a buffer in memory:

Byte buffer create from file content:

```cpp
std::ifstream input( "sched_flat.dat", std::ios::binary );
std::vector<unsigned char> buffer(std::istreambuf_iterator<char>(input), {});
```

Graph created from the buffer:

```cpp
auto ctx = create_graph(buffer.data(),buffer.size(), registered_nodes);
```

It is using the list of registered nodes and a runtime context is returned.

### Running the graph

Before running this graph, some scheduler hooks can be defined to customize the execution:

```cpp
SchedulerHooks hooks;
hooks.before_schedule=nullptr;
hooks.before_iteration=nullptr;

hooks.before_node_execution=nullptr;
hooks.after_node_execution=nullptr;

hooks.after_iteration=nullptr;
hooks.after_schedule=after;

// Only used in async mode
hooks.async_before_node_check=nullptr;
hooks.async_after_node_check=nullptr;
hooks.async_node_not_executed=nullptr;
```



The graph can be run with:

```cpp
uint32_t nbIterations = run_graph(hooks,ctx,&error,INFINITE_SCHEDULING);
```

## Python side

A node needs only two new additional properties.

### UUID

It is the UUID used also in the C code. It replaces the `typeName` property that is used with the compilation version of the library.

```python
@property
    def uuid(self):
        return "3ff62b0c9ad8445dbbe9208d87423446"
```

If the nodes constructors needs to use additional data, this function must generate a byte array. Otherwise it should generate `None`.

Here we are generating an `int`. This byte array is written to the flat buffer and can be sued at runtime to customize a node. It is done in the `mkNode` function.

```python
@property
    def node_data(self):
        return(struct.pack('<i', self._v))
```

Here is how this data is used by the `ProcessingNode`:

```cpp
// Extract values from data
const int8_t *d = ndesc->node_data()->data();
const int32_t *v = reinterpret_cast<const int32_t*>(d);
```

In `mkNode`, we get a pointer to the node data and we cast it to be able to read its content.

