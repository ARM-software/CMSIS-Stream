// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STREAM_ARM_CMSIS_STREAM_H_
#define FLATBUFFERS_GENERATED_STREAM_ARM_CMSIS_STREAM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 ,
             "Non-compatible flatbuffers version included");

namespace arm_cmsis_stream {

struct UUID;

struct IODesc;

struct Node;
struct NodeBuilder;

struct FIFODesc;
struct FIFODescBuilder;

struct Schedule;
struct ScheduleBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) UUID FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t v_[16];

 public:
  UUID()
      : v_() {
  }
  UUID(flatbuffers::span<const uint8_t, 16> _v) {
    flatbuffers::CastToArray(v_).CopyFromSpan(_v);
  }
  const flatbuffers::Array<uint8_t, 16> *v() const {
    return &flatbuffers::CastToArray(v_);
  }
};
FLATBUFFERS_STRUCT_END(UUID, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) IODesc FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t id_;
  uint16_t nb_;

 public:
  IODesc()
      : id_(0),
        nb_(0) {
  }
  IODesc(uint16_t _id, uint16_t _nb)
      : id_(flatbuffers::EndianScalar(_id)),
        nb_(flatbuffers::EndianScalar(_nb)) {
  }
  uint16_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  uint16_t nb() const {
    return flatbuffers::EndianScalar(nb_);
  }
};
FLATBUFFERS_STRUCT_END(IODesc, 4);

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_ID = 6,
    VT_INPUTS = 8,
    VT_OUTPUTS = 10,
    VT_NODE_DATA = 12
  };
  const arm_cmsis_stream::UUID *uuid() const {
    return GetStruct<const arm_cmsis_stream::UUID *>(VT_UUID);
  }
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<const arm_cmsis_stream::IODesc *> *inputs() const {
    return GetPointer<const flatbuffers::Vector<const arm_cmsis_stream::IODesc *> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<const arm_cmsis_stream::IODesc *> *outputs() const {
    return GetPointer<const flatbuffers::Vector<const arm_cmsis_stream::IODesc *> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<int8_t> *node_data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NODE_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<arm_cmsis_stream::UUID>(verifier, VT_UUID, 1) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_NODE_DATA) &&
           verifier.VerifyVector(node_data()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(const arm_cmsis_stream::UUID *uuid) {
    fbb_.AddStruct(Node::VT_UUID, uuid);
  }
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Node::VT_ID, id, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<const arm_cmsis_stream::IODesc *>> inputs) {
    fbb_.AddOffset(Node::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<const arm_cmsis_stream::IODesc *>> outputs) {
    fbb_.AddOffset(Node::VT_OUTPUTS, outputs);
  }
  void add_node_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> node_data) {
    fbb_.AddOffset(Node::VT_NODE_DATA, node_data);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    const arm_cmsis_stream::UUID *uuid = nullptr,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const arm_cmsis_stream::IODesc *>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<const arm_cmsis_stream::IODesc *>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> node_data = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_node_data(node_data);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_uuid(uuid);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const arm_cmsis_stream::UUID *uuid = nullptr,
    uint16_t id = 0,
    const std::vector<arm_cmsis_stream::IODesc> *inputs = nullptr,
    const std::vector<arm_cmsis_stream::IODesc> *outputs = nullptr,
    const std::vector<int8_t> *node_data = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVectorOfStructs<arm_cmsis_stream::IODesc>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVectorOfStructs<arm_cmsis_stream::IODesc>(*outputs) : 0;
  auto node_data__ = node_data ? _fbb.CreateVector<int8_t>(*node_data) : 0;
  return arm_cmsis_stream::CreateNode(
      _fbb,
      uuid,
      id,
      inputs__,
      outputs__,
      node_data__);
}

struct FIFODesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FIFODescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LENGTH = 6,
    VT_DELAY = 8,
    VT_BUFFER = 10
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  uint32_t length() const {
    return GetField<uint32_t>(VT_LENGTH, 0);
  }
  uint32_t delay() const {
    return GetField<uint32_t>(VT_DELAY, 0);
  }
  bool buffer() const {
    return GetField<uint8_t>(VT_BUFFER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_DELAY, 4) &&
           VerifyField<uint8_t>(verifier, VT_BUFFER, 1) &&
           verifier.EndTable();
  }
};

struct FIFODescBuilder {
  typedef FIFODesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(FIFODesc::VT_ID, id, 0);
  }
  void add_length(uint32_t length) {
    fbb_.AddElement<uint32_t>(FIFODesc::VT_LENGTH, length, 0);
  }
  void add_delay(uint32_t delay) {
    fbb_.AddElement<uint32_t>(FIFODesc::VT_DELAY, delay, 0);
  }
  void add_buffer(bool buffer) {
    fbb_.AddElement<uint8_t>(FIFODesc::VT_BUFFER, static_cast<uint8_t>(buffer), 0);
  }
  explicit FIFODescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FIFODesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FIFODesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<FIFODesc> CreateFIFODesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint32_t length = 0,
    uint32_t delay = 0,
    bool buffer = false) {
  FIFODescBuilder builder_(_fbb);
  builder_.add_delay(delay);
  builder_.add_length(length);
  builder_.add_id(id);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

struct Schedule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScheduleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASYNC_MODE = 4,
    VT_NODES = 6,
    VT_FIFOS = 8,
    VT_SCHEDULE = 10
  };
  bool async_mode() const {
    return GetField<uint8_t>(VT_ASYNC_MODE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::Node>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::Node>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::FIFODesc>> *fifos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::FIFODesc>> *>(VT_FIFOS);
  }
  const flatbuffers::Vector<uint16_t> *schedule() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_SCHEDULE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ASYNC_MODE, 1) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_FIFOS) &&
           verifier.VerifyVector(fifos()) &&
           verifier.VerifyVectorOfTables(fifos()) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.VerifyVector(schedule()) &&
           verifier.EndTable();
  }
};

struct ScheduleBuilder {
  typedef Schedule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_async_mode(bool async_mode) {
    fbb_.AddElement<uint8_t>(Schedule::VT_ASYNC_MODE, static_cast<uint8_t>(async_mode), 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::Node>>> nodes) {
    fbb_.AddOffset(Schedule::VT_NODES, nodes);
  }
  void add_fifos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::FIFODesc>>> fifos) {
    fbb_.AddOffset(Schedule::VT_FIFOS, fifos);
  }
  void add_schedule(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> schedule) {
    fbb_.AddOffset(Schedule::VT_SCHEDULE, schedule);
  }
  explicit ScheduleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Schedule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schedule>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schedule> CreateSchedule(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool async_mode = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::Node>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<arm_cmsis_stream::FIFODesc>>> fifos = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> schedule = 0) {
  ScheduleBuilder builder_(_fbb);
  builder_.add_schedule(schedule);
  builder_.add_fifos(fifos);
  builder_.add_nodes(nodes);
  builder_.add_async_mode(async_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Schedule> CreateScheduleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool async_mode = false,
    const std::vector<flatbuffers::Offset<arm_cmsis_stream::Node>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<arm_cmsis_stream::FIFODesc>> *fifos = nullptr,
    const std::vector<uint16_t> *schedule = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<arm_cmsis_stream::Node>>(*nodes) : 0;
  auto fifos__ = fifos ? _fbb.CreateVector<flatbuffers::Offset<arm_cmsis_stream::FIFODesc>>(*fifos) : 0;
  auto schedule__ = schedule ? _fbb.CreateVector<uint16_t>(*schedule) : 0;
  return arm_cmsis_stream::CreateSchedule(
      _fbb,
      async_mode,
      nodes__,
      fifos__,
      schedule__);
}

inline const arm_cmsis_stream::Schedule *GetSchedule(const void *buf) {
  return flatbuffers::GetRoot<arm_cmsis_stream::Schedule>(buf);
}

inline const arm_cmsis_stream::Schedule *GetSizePrefixedSchedule(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<arm_cmsis_stream::Schedule>(buf);
}

inline bool VerifyScheduleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<arm_cmsis_stream::Schedule>(nullptr);
}

inline bool VerifySizePrefixedScheduleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<arm_cmsis_stream::Schedule>(nullptr);
}

inline void FinishScheduleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<arm_cmsis_stream::Schedule> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedScheduleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<arm_cmsis_stream::Schedule> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace arm_cmsis_stream

#endif  // FLATBUFFERS_GENERATED_STREAM_ARM_CMSIS_STREAM_H_
